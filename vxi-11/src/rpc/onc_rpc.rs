use std::mem;
use std::pin::Pin;

use async_std::io::{self, Read};
use async_std::io::prelude::*;
use async_std::net::{ToSocketAddrs, UdpSocket};
use async_std::prelude::*;
use async_std::task::{Context, Poll};
use byteorder::{ByteOrder, NetworkEndian, WriteBytesExt};
use futures::{AsyncBufRead, AsyncReadExt, AsyncWriteExt, Stream};
use pin_project::pin_project;

#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub(in crate::rpc) mod xdr {
    //! Autogenerated by xdrgen
    use xdr_codec;

    #[allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/onc_rpc_xdr.rs"));

    impl Default for rpc_msg {
        fn default() -> Self {
            rpc_msg {
                xid: 0,
                body: _body::REPLY(reply_body::MSG_DENIED(
                    rejected_reply::RPC_MISMATCH(_missmatch_info { high: 0, low: 0 }),
                )),
            }
        }
    }

    impl Default for opaque_auth {
        fn default() -> Self {
            opaque_auth {
                flavor: auth_flavor::AUTH_NONE,
                body: vec![]
            }
        }
    }
}

async fn write_message<W: WriteExt + Unpin, P: xdr_codec::Pack<Vec<u8>>>(
    writer: &mut W,
    msg: &xdr::rpc_msg,
    payload: P,
) -> io::Result<()> {
    let mut buf = Vec::new();

    xdr_codec::pack(msg, &mut buf)
        .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "Failed to pack message"))?;
    xdr_codec::pack(&payload, &mut buf)
        .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "Failed to pack payload"))?;
    let mut header = [0u8; 4];
    NetworkEndian::write_u32(&mut header, buf.len() as u32 & 0x8000_0000);
    writer.write_all(&header).await?;
    writer.write_all(buf.as_slice()).await
}

#[pin_project]
pub(crate) struct RpcDecoder<R> {
    #[pin]
    pub(crate) reader: R,
    pub(crate) buf: Vec<u8>,
    pub(crate) bytes: Vec<u8>,
    pub(crate) read: usize,
}

impl<R> RpcDecoder<R> {
    pub(crate) fn new(reader: R) -> Self {
        Self {
            reader,
            buf: vec![],
            bytes: vec![],
            read: 0
        }
    }
}

#[pin_project]
pub(crate) struct RpcEncoder<W> {
    #[pin]
    pub(crate) writer: W,
    pub(crate) buf: Vec<u8>,
    pub(crate) bytes: Vec<u8>,
    pub(crate) read: usize,
}

impl<R: BufReadExt> Stream for RpcDecoder<R> {
    type Item = io::Result<Vec<u8>>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let this = self.project();
        let n = futures::ready!(read_frame_internal(
            this.reader,
            cx,
            this.buf,
            this.bytes,
            this.read
        ))?;
        if n == 0 {
            return Poll::Ready(None);
        }

        Poll::Ready(Some(Ok(mem::replace(
            this.buf,
            vec![]
        ))))
    }
}

pub fn read_frame_internal<R: AsyncBufRead + ?Sized>(
    reader: Pin<&mut R>,
    cx: &mut Context<'_>,
    buf: &mut Vec<u8>,
    bytes: &mut Vec<u8>,
    read: &mut usize,
) -> Poll<io::Result<usize>> {
    use std::io::Cursor;
    use xdr_codec::Unpack;

    let ret = futures::ready!(read_until_finished(reader, cx, bytes, read));
    mem::swap(buf, bytes);
    Poll::Ready(ret)
}

pub fn read_until_finished<R: BufReadExt + ?Sized>(
    mut reader: Pin<&mut R>,
    cx: &mut Context<'_>,
    buf: &mut Vec<u8>,
    read: &mut usize,
) -> Poll<io::Result<usize>> {
    loop {
        let (done, used) = {
            let available = futures::ready!(reader.as_mut().poll_fill_buf(cx))?;
            // Try to read the header
            if available.len() >= 4 {
                // Complete header
                let header = NetworkEndian::read_u32(&available[0..4]);
                let last = (header & 0x8000_0000u32) != 0;
                let fragment_len = (header & 0x7fff_ffffu32) as usize;
                // Check that full fragment is available
                if available.len() >= fragment_len + 4 {
                    buf.extend_from_slice(&available[4..fragment_len + 4]);
                    (last, fragment_len + 4)
                } else {
                    (false, 0)
                }
            } else {
                (false, 0)
            }
        };
        reader.as_mut().consume(used);
        *read += used;
        if done || used == 0 {
            return Poll::Ready(Ok(mem::replace(read, 0)));
        }
    }
}

#[cfg(test)]
mod tests {
    use std::io::Cursor;

    use async_std::io::BufReader;

    fn test_reader() {}
}
