use std::mem;
use std::pin::Pin;

use async_std::io::prelude::*;
use async_std::io::{self};

use async_std::prelude::*;
use async_std::task::{Context, Poll};
use byteorder::{ByteOrder, NetworkEndian, WriteBytesExt};
use futures::{AsyncBufRead, Stream};
use pin_project::pin_project;
use std::io::Cursor;

#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub(in crate::rpc) mod xdr {
    //! Autogenerated by xdrgen
    use xdr_codec;

    #[allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/onc_rpc_xdr.rs"));

    impl rpc_msg {
        pub(crate) fn reply_msg_denied(xid: u32, rj: rejected_reply) -> Self {
            rpc_msg {
                xid,
                body: _body::REPLY(reply_body::MSG_DENIED(rj)),
            }
        }

        pub(crate) fn reply_msg_accepted(xid: u32, ar: accepted_reply) -> Self {
            rpc_msg {
                xid,
                body: _body::REPLY(reply_body::MSG_ACCEPTED(ar)),
            }
        }
    }

    impl Default for rpc_msg {
        fn default() -> Self {
            rpc_msg {
                xid: 0,
                body: _body::REPLY(reply_body::MSG_DENIED(rejected_reply::RPC_MISMATCH(
                    _missmatch_info { high: 0, low: 0 },
                ))),
            }
        }
    }

    impl Default for opaque_auth {
        fn default() -> Self {
            opaque_auth {
                flavor: auth_flavor::AUTH_NONE,
                body: vec![],
            }
        }
    }
}

pub(crate) async fn write_tcp_message<W: WriteExt + Unpin, P: xdr_codec::Pack<Cursor<Vec<u8>>>>(
    writer: &mut W,
    msg: &xdr::rpc_msg,
    payload: P,
) -> io::Result<()> {
    use xdr_codec::Pack;

    let buf: Vec<u8> = vec![];
    let mut cur = Cursor::new(buf);
    cur.write_u32::<NetworkEndian>(0)?;
    msg.pack(&mut cur).unwrap();
    payload.pack(&mut cur).unwrap();
    let len = cur.position();
    cur.set_position(0);
    cur.write_u32::<NetworkEndian>((len - 4) as u32 | 0x8000_0000)?;
    //let mut header = [0u8; 4];
    //NetworkEndian::write_u32(&mut header, cur.position() as u32 | 0x8000_0000);
    //writer.write_all(&header).await?;
    writer.write_all(cur.get_ref().as_slice()).await
}

#[pin_project]
pub(crate) struct RpcTcpDeframer<R> {
    #[pin]
    pub(crate) reader: R,
    pub(crate) buf: Vec<u8>,
    pub(crate) bytes: Vec<u8>,
    pub(crate) read: usize,
}

impl<R> RpcTcpDeframer<R> {
    pub(crate) fn new(reader: R) -> Self {
        Self {
            reader,
            buf: vec![],
            bytes: vec![],
            read: 0,
        }
    }
}

impl<R: BufReadExt> Stream for RpcTcpDeframer<R> {
    type Item = io::Result<Vec<u8>>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let this = self.project();
        let n = futures::ready!(read_frame_internal(
            this.reader,
            cx,
            this.buf,
            this.bytes,
            this.read
        ))?;
        if n == 0 {
            return Poll::Ready(None);
        }

        Poll::Ready(Some(Ok(mem::replace(this.buf, vec![]))))
    }
}

pub fn read_frame_internal<R: AsyncBufRead + ?Sized>(
    reader: Pin<&mut R>,
    cx: &mut Context<'_>,
    buf: &mut Vec<u8>,
    bytes: &mut Vec<u8>,
    read: &mut usize,
) -> Poll<io::Result<usize>> {
    let ret = futures::ready!(read_until_finished(reader, cx, bytes, read));
    mem::swap(buf, bytes);
    Poll::Ready(ret)
}

pub fn read_until_finished<R: BufReadExt + ?Sized>(
    mut reader: Pin<&mut R>,
    cx: &mut Context<'_>,
    buf: &mut Vec<u8>,
    read: &mut usize,
) -> Poll<io::Result<usize>> {
    loop {
        let (done, used) = {
            let available = futures::ready!(reader.as_mut().poll_fill_buf(cx))?;
            // Try to read the header
            if available.len() >= 4 {
                // Complete header
                let header = NetworkEndian::read_u32(&available[0..4]);
                let last = (header & 0x8000_0000u32) != 0;
                let fragment_len = (header & 0x7fff_ffffu32) as usize;
                // Check that full fragment is available
                if available.len() >= fragment_len + 4 {
                    buf.extend_from_slice(&available[4..fragment_len + 4]);
                    (last, fragment_len + 4)
                } else {
                    (false, 0)
                }
            } else {
                (false, 0)
            }
        };
        reader.as_mut().consume(used);
        *read += used;
        if done || used == 0 {
            return Poll::Ready(Ok(mem::replace(read, 0)));
        }
    }
}

#[cfg(test)]
mod tests {

    fn test_reader() {}
}
