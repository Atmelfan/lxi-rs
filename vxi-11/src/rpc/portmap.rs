use crate::rpc::{RpcClient, RpcProto, RpcTcpClient};
use async_std::net::ToSocketAddrs;

#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub(crate) mod xdr {
    //! Autogenerated by xdrgen
    use crate::rpc::RpcProto;
    use xdr_codec;

    #[allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/portmap_xdr.rs"));

    impl mapping {
        pub(crate) fn new(prog: u32, vers: u32, prot: RpcProto, port: u32) -> Self {
            mapping {
                prog,
                vers,
                prot: prot.prot(),
                port,
            }
        }
    }

    pub(crate) const PMAP_PROGRAM_ID: u32 = 100000;

    /// Null procedure
    pub(crate) const PMAPPROC_NULL: u32 = 0;
    /// Set procedure
    pub(crate) const PMAPPROC_SET: u32 = 1;
    /// Unset procedure
    pub(crate) const PMAPPROC_UNSET: u32 = 2;
    /// Getport procedure
    pub(crate) const PMAPPROC_GETPORT: u32 = 3;
    /// Dump procedure
    pub(crate) const PMAPPROC_DUMP: u32 = 4;
    /// Callit procedure
    pub(crate) const PMAPPROC_CALLIT: u32 = 5;
}

pub(crate) struct PortmapTcpClient<CLIENT> {
    client: CLIENT,
}

impl<CLIENT: RpcClient> PortmapTcpClient<CLIENT> {
    async fn set(
        &mut self,
        prog: u32,
        vers: u32,
        proto: RpcProto,
        port: u16,
    ) -> crate::rpc::Result<bool> {
        let mapping = xdr::mapping::new(prog, vers, proto, port.into());
        self.client
            .call::<xdr::mapping, bool>(xdr::PMAPPROC_SET, mapping)
            .await
    }

    async fn unset(&mut self, prog: u32, vers: u32, proto: RpcProto) -> crate::rpc::Result<bool> {
        let mapping = xdr::mapping::new(prog, vers, proto, 0);
        self.client.call(xdr::PMAPPROC_UNSET, mapping).await
    }

    async fn get_port(&mut self, prog: u32, vers: u32, proto: RpcProto) -> crate::rpc::Result<u32> {
        let mapping = xdr::mapping::new(prog, vers, proto, 0);
        self.client.call(xdr::PMAPPROC_GETPORT, mapping).await
    }
}

impl PortmapTcpClient<RpcTcpClient> {
    fn new() -> Self {
        PortmapTcpClient {
            client: RpcTcpClient::new(xdr::PMAP_PROGRAM_ID, 2),
        }
    }

    async fn connect(&mut self, addr: impl ToSocketAddrs) -> crate::rpc::Result<()> {
        self.client.connect(addr).await
    }
}

#[cfg(test)]
mod tests {
    use crate::rpc::portmap::PortmapTcpClient;

    use crate::rpc::RpcProto;

    /// Test portmap functions by creating and destroying a service
    ///
    #[async_std::test]
    async fn test_portmap_tcp() {
        let mut client = PortmapTcpClient::new();
        client.connect("127.0.0.1:111").await.unwrap();
        assert!(client
            .set(0x20000000, 1, RpcProto::Tcp, 1024)
            .await
            .unwrap());
        let port = client.get_port(0x20000000, 1, RpcProto::Tcp).await.unwrap();
        assert_eq!(port, 1024);
        assert!(client.unset(0x20000000, 1, RpcProto::Tcp).await.unwrap());
    }
}
