use async_std::net::ToSocketAddrs;
use crate::rpc::{RpcProto, RpcService, RpcClient, RpcTcpClient};

#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub(crate) mod xdr {
    //! Autogenerated by xdrgen
    use xdr_codec;
    use crate::rpc::RpcProto;

    #[allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/portmap_xdr.rs"));

    impl mapping {
        pub(crate) fn new(prog: u32, vers: u32, prot: RpcProto, port: u32) -> Self {
            mapping {
                prog,
                vers,
                prot: prot.prot(),
                port
            }
        }
    }

    pub(crate) const PMAP_PROGRAM_ID: u32 = 1000000;

    /// Null procedure
    pub(crate) const PMAPPROC_NULL: u32 = 0;
    /// Set procedure
    pub(crate) const PMAPPROC_SET: u32 = 1;
    /// Unset procedure
    pub(crate) const PMAPPROC_UNSET: u32 = 2;
    /// Getport procedure
    pub(crate) const PMAPPROC_GETPORT: u32 = 3;
    /// Dump procedure
    pub(crate) const PMAPPROC_DUMP: u32 = 4;
    /// Callit procedure
    pub(crate) const PMAPPROC_CALLIT: u32 = 5;
}

pub(crate) struct PortmapClient {
    client: RpcTcpClient
}

impl PortmapClient {
    fn new() -> Self {
        PortmapClient {
            client: RpcTcpClient::new(xdr::PMAP_PROGRAM_ID, 2)
        }
    }
    
    async fn set(&self, prog: u32, vers: u32, proto: RpcProto, port: u16) {

    }

    async fn unset(&self, prog: u32, vers: u32, proto: RpcProto) {

    }

    async fn get_port(&self, prog: u32, vers: u32, proto: RpcProto) -> Option<u16> {
        None
    }

}